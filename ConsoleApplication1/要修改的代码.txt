#include <easyx.h>
#include <graphics.h>
#include <cmath>
#include <vector>
#include <memory>
#include <conio.h>




void drawButton() {
    BeginBatchDraw();
    setfillcolor(WHITE);
    solidrectangle(650, 50, 750, 100);
    solidrectangle(650, 150, 750, 200);
    solidrectangle(650, 250, 750, 300);
    solidrectangle(650, 350, 750, 400);
    solidrectangle(650, 450, 750, 500);
	solidrectangle(650, 550, 750, 600);

    settextstyle(30, 0, _T("Consolas"));
    settextcolor(WHITE);
    outtextxy(655, 60, _T("Draw Circle"));
    outtextxy(655, 160, _T("Draw Rect"));
    outtextxy(655, 260, _T("Draw Zhexian"));
    outtextxy(655, 360, _T("Draw Duo"));
    outtextxy(655, 460, _T("Select Shape"));
	outtextxy(655, 560, _T("Draw Tuoyuan"));
    EndBatchDraw();
}

// 基类 Shape，所有图形的抽象基类
class Shape {
public:
    virtual void draw() const = 0;
    virtual RECT getBoundingBox() const = 0;
    virtual void move(int dx, int dy) = 0;
    virtual ~Shape() {}
    int color = WHITE;
    bool is_fill = false; // 新增成员变量

    virtual void setColor(int co) {
        this->color = co;
    }

    void setFill(bool fill) {
        this->is_fill = fill;
    }
};

// 派生类 Circle，表示圆形
class Circle : public Shape {
public:
    Circle(POINT center, int radius) : center(center), radius(radius) {}
    void draw() const override {
        setlinecolor(color);
        if (is_fill) {
            setfillcolor(RED);
            solidcircle(center.x, center.y, radius);
        }
        else {
            circle(center.x, center.y, radius);
        }
        setlinecolor(WHITE);
    }
    RECT getBoundingBox() const override {
        return { center.x - radius, center.y - radius, center.x + radius, center.y + radius };
    }
    void move(int dx, int dy) override {
        center.x += dx;
        center.y += dy;
    }
private:
    POINT center;
    int radius;
};

// 派生类 Rect，表示矩形
class Rect : public Shape {
public:
    Rect(POINT topLeft, POINT bottomRight) : topLeft(topLeft), bottomRight(bottomRight) {}
    void draw() const override {
        setlinecolor(color);
        if (is_fill) {
            setfillcolor(RED);
            solidrectangle(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);
        }
        else {
            rectangle(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);
        }
        setlinecolor(WHITE);
    }
    RECT getBoundingBox() const override {
        return { topLeft.x, topLeft.y, bottomRight.x, bottomRight.y };
    }
    void move(int dx, int dy) override {
        topLeft.x += dx;
        topLeft.y += dy;
        bottomRight.x += dx;
        bottomRight.y += dy;
    }
private:
    POINT topLeft;
    POINT bottomRight;
};

// 派生类 Zhexian，表示折线
class Zhexian : public Shape {
public:
    void addPoint(POINT pt) {
        points.push_back(pt);
    }
    void updateLastPoint(POINT pt) {
        if (!points.empty()) {
            points.back() = pt;
        }
    }
    void draw() const override {
        if (points.size() < 2) return;
        if (is_fill && points.size() > 2) {
            setfillcolor(RED);
            solidpolygon(&points[0], points.size());
        }
        else {
            for (size_t i = 0; i < points.size() - 1; ++i) {
                setlinecolor(color);
                line(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y);
            }
        }
        setlinecolor(WHITE);
    }
    RECT getBoundingBox() const override {
        if (points.empty()) return { 0, 0, 0, 0 };
        int minX = points[0].x, maxX = points[0].x, minY = points[0].y, maxY = points[0].y;
        for (const auto& pt : points) {
            if (pt.x < minX) minX = pt.x;
            if (pt.x > maxX) maxX = pt.x;
            if (pt.y < minY) minY = pt.y;
            if (pt.y > maxY) maxY = pt.y;
        }
        return { minX, minY, maxX, maxY };
    }
    void move(int dx, int dy) override {
        for (auto& pt : points) {
            pt.x += dx;
            pt.y += dy;
        }
    }
private:
    std::vector<POINT> points;
};

class Tuoyuan : public Shape {
public:
    Tuoyuan(POINT topLeft, POINT bottomRight) : topLeft(topLeft), bottomRight(bottomRight) {}
    void draw() const override {
        setlinecolor(color);
        if (is_fill) {
            setfillcolor(RED);
            solidellipse(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);
        }
        else {
            ellipse(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);
        }
        setlinecolor(WHITE);
    }
    RECT getBoundingBox() const override {
        return { topLeft.x, topLeft.y, bottomRight.x, bottomRight.y };
    }
    void move(int dx, int dy) override {
        topLeft.x += dx;
        topLeft.y += dy;
        bottomRight.x += dx;
        bottomRight.y += dy;
    }
private:
    POINT topLeft;
    POINT bottomRight;
};



// 派生类 Duo，表示多边形
class Duo : public Shape {
public:
    void addPoint(POINT pt) {
        points.push_back(pt);
    }
    void updateLastPoint(POINT pt) {
        if (!points.empty()) {
            points.back() = pt;
        }
    }
    void draw() const override {
        if (points.size() < 3) return;
        setlinecolor(color);
        if (is_fill) {
            setfillcolor(RED);
            solidpolygon(&points[0], points.size());
        }
        else {
            polygon(&points[0], points.size());
        }
        setlinecolor(WHITE);
    }
    RECT getBoundingBox() const override {
        if (points.empty()) return { 0, 0, 0, 0 };
        int minX = points[0].x, maxX = points[0].x, minY = points[0].y, maxY = points[0].y;
        for (const auto& pt : points) {
            if (pt.x < minX) minX = pt.x;
            if (pt.x > maxX) maxX = pt.x;
            if (pt.y < minY) minY = pt.y;
            if (pt.y > maxY) maxY = pt.y;
        }
        return { minX, minY, maxX, maxY };
    }
    void move(int dx, int dy) override {
        for (auto& pt : points) {
            pt.x += dx;
            pt.y += dy;
        }
    }
private:
    std::vector<POINT> points;
};

// 全局变量
std::vector<std::shared_ptr<Shape>> shapes;
std::shared_ptr<Zhexian> currentZhexian;
std::shared_ptr<Duo> currentDuo;
bool isDrawingCircle = false;
bool isDrawingRect = false;
bool isDrawingZhexian = false;
bool isDrawingDuo = false;
bool isDrawingTuoyuan = false;
bool drawCircleMode = false;
bool drawRectMode = false;
bool drawZhexianMode = false;
bool drawDuoMode = false;
bool drawTuoyuanMode = false;
bool selectMode = false;
POINT startPoint;
POINT endPoint;
int selectedIndex = -1;
bool isDragging = false;
POINT lastMousePos;

// 绘制所有的图形
void DrawAllShapes() {
    BeginBatchDraw();
    cleardevice();
    drawButton();
    // 绘制所有形状
    for (const auto& shape : shapes) {
        shape->draw();
    }

    // 绘制当前绘制中的形状
    if (isDrawingCircle) {
        int radius = static_cast<int>(std::sqrt(std::pow(endPoint.x - startPoint.x, 2) + std::pow(endPoint.y - startPoint.y, 2)));
        Circle tempCircle(startPoint, radius);
        tempCircle.draw();
    }
    else if (isDrawingRect) {
        Rect tempRect(startPoint, endPoint);
        tempRect.draw();
    }
    else if (isDrawingZhexian && currentZhexian) {
        currentZhexian->draw();
    }
    else if (isDrawingDuo && currentDuo) {
        currentDuo->draw();
    }
    else if (isDrawingTuoyuan) {
        Tuoyuan tempTuoyuan(startPoint, endPoint);
        tempTuoyuan.draw();
    }


    // 绘制选中的形状的外框
    if (selectedIndex != -1) {
        RECT bbox = shapes[selectedIndex]->getBoundingBox();
        setlinecolor(YELLOW);
        rectangle(bbox.left - 5, bbox.top - 5, bbox.right + 5, bbox.bottom + 5);
        setlinecolor(WHITE);
    }
    EndBatchDraw();
}




int main() {
    // 初始化图形窗口
    initgraph(1200, 800);
    setbkcolor(BLACK);
    cleardevice();

    while (true) {
        // 获取鼠标消息
        MOUSEMSG msg = GetMouseMsg();

        POINT pt = { msg.x, msg.y };
        if (!selectMode) { selectedIndex = -1; }
        drawButton();
        switch (msg.uMsg) {
        case WM_LBUTTONDOWN:
            // 检查是否点击了按钮
            if (pt.x >= 650 && pt.x <= 750) {
                if (pt.y >= 50 && pt.y <= 100) {
                    drawCircleMode = true;
                    drawRectMode = false;
                    drawZhexianMode = false;
                    drawDuoMode = false;
                    selectMode = false;
                    drawTuoyuanMode = false;
                    continue;
                }
                else if (pt.y >= 150 && pt.y <= 200) {
                    drawCircleMode = false;
                    drawRectMode = true;
                    drawZhexianMode = false;
                    drawDuoMode = false;
                    selectMode = false;
                    drawTuoyuanMode = false;
                    continue;
                }
                else if (pt.y >= 250 && pt.y <= 300) {
                    drawCircleMode = false;
                    drawRectMode = false;
                    drawZhexianMode = true;
                    drawDuoMode = false;
                    selectMode = false;
                    drawTuoyuanMode = false;
                    continue;
                }
                else if (pt.y >= 350 && pt.y <= 400) {
                    drawCircleMode = false;
                    drawRectMode = false;
                    drawZhexianMode = false;
                    drawDuoMode = true;
                    selectMode = false;
                    drawTuoyuanMode = false;
                    continue;
                }
                else if (pt.y >= 450 && pt.y <= 500) {
                    drawCircleMode = false;
                    drawRectMode = false;
                    drawZhexianMode = false;
                    drawDuoMode = false;
                    selectMode = true;
                    drawTuoyuanMode = false;
                    continue;
                }
                else if (pt.y >= 550 && pt.y <= 600) {
                    drawCircleMode = false;
                    drawRectMode = false;
                    drawTuoyuanMode = true; // 打开绘制椭圆模式
                    drawZhexianMode = false;
                    drawDuoMode = false;
                    selectMode = false;
                    continue;
                }
                break;
            }

            if (drawCircleMode) {
                // 左键按下，开始绘制圆
                isDrawingCircle = true;
                startPoint = pt;
                endPoint = startPoint;
            }
            else if (drawRectMode) {
                // 左键按下，开始绘制矩形
                isDrawingRect = true;
                startPoint = pt;
                endPoint = startPoint;
            }
            else if (drawTuoyuanMode) {
                startPoint = { msg.x, msg.y };
                isDrawingTuoyuan = true;
            }
            else if (drawZhexianMode) {
                // 左键按下，绘制折线
                if (!isDrawingZhexian) {
                    isDrawingZhexian = true;
                    currentZhexian = std::make_shared<Zhexian>();
                    currentZhexian->addPoint(pt);
                }
                else if (isDrawingZhexian && currentZhexian) {
                    currentZhexian->addPoint(pt);
                    DrawAllShapes();
                }
            }
            else if (drawDuoMode) {
                // 左键按下，绘制多边形
                if (!isDrawingDuo) {
                    isDrawingDuo = true;
                    currentDuo = std::make_shared<Duo>();
                    currentDuo->addPoint(pt);
                }
                else if (isDrawingDuo && currentDuo) {
                    currentDuo->addPoint(pt);
                    DrawAllShapes();
                }
            }
            else if (selectMode && selectedIndex != -1) {
                // 左键按下，开始拖动选中的图形
                isDragging = true;
                lastMousePos = pt;
            }
            break;

        case WM_RBUTTONDOWN:
            // 右键按下，结束折线绘制或多边形绘制
            if (isDrawingZhexian && currentZhexian) {
                shapes.push_back(currentZhexian);
                currentZhexian.reset();
                isDrawingZhexian = false;
                DrawAllShapes();
            }
            else if (isDrawingDuo && currentDuo) {
                shapes.push_back(currentDuo);
                currentDuo.reset();
                isDrawingDuo = false;
                DrawAllShapes();
            }
            break;

        case WM_MOUSEMOVE:
            // 鼠标移动，更新终点并重绘
            if (isDrawingCircle || isDrawingRect || isDrawingTuoyuan) {
                endPoint = pt;
                DrawAllShapes();
            }
            else if (isDrawingZhexian && currentZhexian) {
                currentZhexian->updateLastPoint(pt);
                DrawAllShapes();
            }
            else if (isDrawingDuo && currentDuo) {
                currentDuo->updateLastPoint(pt);
                DrawAllShapes();
            }
            else if (isDragging && selectedIndex != -1) {
                // 移动选中的图形
                int dx = pt.x - lastMousePos.x;
                int dy = pt.y - lastMousePos.y;
                shapes[selectedIndex]->move(dx, dy);
                lastMousePos = pt;
                DrawAllShapes();
            }
            break;

        case WM_LBUTTONUP:
            // 左键松开，保存图形并结束绘制
            if (isDrawingCircle) {
                isDrawingCircle = false;
                endPoint = pt;
                int radius = static_cast<int>(std::sqrt(std::pow(endPoint.x - startPoint.x, 2) + std::pow(endPoint.y - startPoint.y, 2)));
                shapes.push_back(std::make_shared<Circle>(startPoint, radius));
                DrawAllShapes();
            }
            else if (isDrawingRect) {
                isDrawingRect = false;
                endPoint = pt;
                shapes.push_back(std::make_shared<Rect>(startPoint, endPoint));
                DrawAllShapes();
            }
            else if (drawZhexianMode) {
                if (isDrawingZhexian && currentZhexian) {
                    currentZhexian->addPoint(pt);
                    DrawAllShapes();
                }
            }
            else if (drawDuoMode) {
                if (isDrawingDuo && currentDuo) {
                    currentDuo->addPoint(pt);
                    DrawAllShapes();
                }
            }
            else if (isDrawingTuoyuan) {
                shapes.push_back(std::make_shared<Tuoyuan>(startPoint, endPoint));
                isDrawingTuoyuan = false;
            }
            else if (isDragging && selectedIndex != -1) {
                // 停止拖动图形
                isDragging = false;
            }
            break;

        case WM_KEYDOWN:
            // 按下 ESC 键退出程序
            if (msg.mkCtrl == 1) { // 检查是否按下了 Ctrl 键
                if (isDrawingZhexian && currentZhexian) {
                    shapes.push_back(currentZhexian);
                }
                if (isDrawingDuo && currentDuo) {
                    shapes.push_back(currentDuo);
                }
                closegraph();
                return 0;
            }
            break;

        case WM_MOUSEWHEEL:
            if (selectMode) {
                short temp = msg.wheel;
                // 选择模式下，鼠标滚轮选择图形
                if (temp == 120) {
                    if (!shapes.empty()) {
                        selectedIndex = (selectedIndex - 1 + shapes.size()) % shapes.size();
                        DrawAllShapes();
                    }
                }
                else {
                    if (!shapes.empty()) {
                        selectedIndex = (selectedIndex + 1) % shapes.size();
                        DrawAllShapes();
                    }
                }
            }
            break;

        case WM_MBUTTONDOWN:
            // 中键按下，将选中的图形设为填充
            if (selectMode && selectedIndex != -1) {
                shapes[selectedIndex]->setFill(!shapes[selectedIndex]->is_fill);
                DrawAllShapes();
            }
            break;
        }
    }

    closegraph();
    return 0;
}
